---
title: 'stars: data model'
author: "Edzer Pebesma"
date: "December 10, 2017"
output:
  html_document:
    toc: true
    theme: united
vignette: >
  %\VignetteIndexEntry{Stars: data model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(collapse = TRUE)
set.seed(13579)
```

This vignette explains the data model of `stars` objects, with illustrations.

## Grid types

### Regular grids
With a very simple file created from a $4 \times 5$ matrix
```{r fig.width=4.5, fig.height=4}
suppressPackageStartupMessages(library(stars))
m = matrix(1:20, nrow = 5, ncol = 4)
dim(m) = c(x = 5, y = 4) # named dim
(s = st_as_stars(m))
```
we see that

* the rows (5) are mapped to the first dimension, the x-coordinate
* the columns (4) are mapped to the second dimension, the y-coordinate
* the `from` and `to` fields of the dimensions are redundant, as they also are present in the array dimension:

```{r}
dim(s[[1]])
```
* offset and delta specify how increasing row/column index maps to x and y coordinate values

When we plot this object, using the `image` method for `stars` objects, we see
```{r fig.width=4.5, fig.height=4}
image(s, text_values = TRUE, axes = TRUE)
```

Where it becomes clear that $(0,0)$ is the origin of the grid (grid corner), and $1$ the coordinate value increase from one index (row, col) to the next. It means that consecutive matrix columns represent grid lines, going from south to north. Grids defined this way are **regular**: grid cell size is constant everywhere.

Most grid data comes with y coordinates (grid rows) going from North to South (top to bottom); this is established using a negative `delta`. We see that the grid origing $(0,0)$ did not change:
```{r fig.width=4.5, fig.height=4}
attr(s, "dimensions")[[2]]$delta = -1
image(s, text_values = TRUE, axes = TRUE)
```

An example is the GeoTIFF carried in the package, which has a negative `delta` for the `y`-coordinate:
```{r}
tif = system.file("tif/L7_ETMs.tif", package = "stars")
st_dimensions(read_stars(tif))["y"]
```

### Regular grids: rotated

`x` and `y` coordinate grids carry a `geotransform` field, used to compute $x$ and $y$ coordinates from grid index $i$ and $j$:

$$x = gt_1 + (i-1) gt_2 + (j-1) gt_3$$
    
$$y = gt_4 + (i-1) gt_5 + (j-1) gt_6$$
We can rotate grids by setting $gt_3$ and $gt_5$ to a constant, non-zero value:

```{r}
attr(attr(s, "dimensions"), "raster")$affine = c(0.1, 0.1)
# FIXME: use image()
plot(st_as_sf(s, as_points = FALSE), axes = TRUE, nbreaks = 20)
```

The rotation angle, in degrees, is

```{r}
atan2(0.1, 1) * 180 / pi
```

### Regular grids: sheared, sheared and rotated

Sheared grids are obtained when the two rotation coefficients, $gt_3$ and $gt_5$, are unequal:
```{r}
attr(attr(s, "dimensions"), "raster")$affine = c(0.1, 0.2)
plot(st_as_sf(s, as_points = FALSE), axes = TRUE, nbreaks = 20)
```

Now, the y-axis and x-axis have different rotation in degrees of respectively
```{r}
atan2(c(0.1, 0.2), 1) * 180 / pi
```

## Rectilinear grids

[Rectilinear grids](https://en.wikipedia.org/wiki/Regular_grid) have orthogonal axes, but do not have congruent (equally sized and shaped) cells: each axes has its own irregular subdivision.

```{r}
x = c(0,0.5,1,2,4,5)
y = c(0.3,0.5,1,2,2.2)
r = st_as_stars(list(m = m), dimensions = st_dimensions(x = x, y = y))
r
#plot(st_as_sf(r, as_points = FALSE), axes = TRUE, nbreaks = 20)
image(x, y, m, col = sf.colors(21))
x1 = c(0.25,0.75,1.5,3,4.5)
y1 = c(0.4,0.75,1.5,2.1)
image(x1, y1, m, col = sf.colors(21))
```

## Curvilinear grids

Curvilinear grids are grids whose grid lines are not straight. Rather than describing the curvature parametrically, the typical (HDF5 or netcdf) files in which they are found have two raster layers, one with the latitudes and one with the longitudes for every grid cell. Using the GDAL interface, we need to compose a `stars` object from the array and a long and lat matrix. The matrices with longitude and latitude values are stored in the `values` field of their respective dimensions.

As an example, we will use a Sentinel 5P dataset available from package `starsdata`; this package can be installed with
```{r eval=FALSE}
install.packages("starsdata", repos = "http://pebesma.staff.ifgi.de", type = "source") 
```

The dataset is found here:
```{r}
(s5p = system.file("sentinel5p/S5P_NRTI_L2__NO2____20180717T120113_20180717T120613_03932_01_010002_20180717T125231.nc", package = "starsdata"))
```

```{r echo=FALSE}
EVAL = s5p != ""
```
We can construct the curvilinear `stars` raster by calling `st_as_stars` on three arrays, with data, longitude and latitudes:
```{r eval=EVAL}
lat_ds = paste0("HDF5:\"", s5p, "\"://PRODUCT/latitude")
lon_ds = paste0("HDF5:\"", s5p, "\"://PRODUCT/longitude")
nit_ds = paste0("HDF5:\"", s5p, "\"://PRODUCT/SUPPORT_DATA/DETAILED_RESULTS/nitrogendioxide_summed_total_column")
lat = read_stars(lat_ds)
lon = read_stars(lon_ds)
nit = read_stars(nit_ds)
nit[[1]][nit[[1]] > 9e+36] = NA

ll = setNames(c(lon, lat), c("x", "y"))
nit.c = st_as_stars(nit, curvilinear = ll)
st_crs(nit.c) = 4326
nit.c
```

```{r eval=EVAL}
plot(nit.c, breaks = "equal", reset = FALSE, axes = TRUE, as_points = TRUE, pch = 16, key.pos = NULL)
library(rnaturalearth)
plot(st_geometry(ne_countries(scale = "medium", returnclass="sf")), add = TRUE, border = 'grey')
```

```{r eval=EVAL}
plot(nit.c, breaks = "equal", reset = FALSE, axes = TRUE, as_points = FALSE, border = NA)
plot(st_geometry(ne_countries(scale = "medium", returnclass="sf")), add = TRUE, border = 'grey')
```

We can downsample the data by
```{r eval=EVAL}
(nit.c = stars:::st_downsample(nit.c, 8))
plot(nit.c, breaks = "equal", reset = FALSE, axes = TRUE, as_points = TRUE, pch = 16)
plot(st_geometry(ne_countries(scale = "medium", returnclass="sf")), add = TRUE, border = 'grey')
```

which doesn't look nice, but plotting the cells as polygons looks better:
```{r eval=EVAL}
plot(nit.c, breaks = "equal", reset = FALSE, axes = TRUE, as_points = FALSE, border = NA)
plot(st_geometry(ne_countries(scale = "medium", returnclass="sf")), add = TRUE, border = 'grey')
```
