---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file - rmarkdown::render('README.Rmd', output_format = 'github_document', output_file = 'README.md') -->


```{r readme-setup, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#",
  #fig.path = "https://raw.githubusercontent.com/r-spatial/stars/master/images/"
  fig.path = "images/"
)
is_online = curl::has_internet()
```

# Spatiotemporal Arrays: Raster and Vector Datacubes

[![Build Status](https://travis-ci.org/r-spatial/stars.png?branch=master)](https://travis-ci.org/r-spatial/stars) [![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/r-spatial/stars?branch=master&svg=true)](https://ci.appveyor.com/project/edzerpebesma/stars)
[![codecov](https://codecov.io/gh/r-spatial/stars/branch/master/graph/badge.svg)](https://codecov.io/gh/r-spatial/stars)
[![CRAN](http://www.r-pkg.org/badges/version/stars)](https://cran.r-project.org/package=stars) 
[![cran checks](https://cranchecks.info/badges/worst/stars)](https://cran.r-project.org/web/checks/check_results_stars.html)
[![Downloads](http://cranlogs.r-pkg.org/badges/stars?color=brightgreen)](http://www.r-pkg.org/pkg/stars)

Spatiotemporal data often comes in the form of dense arrays, with space and time being array dimensions. Examples include

-   socio-economic or demographic data,
-   environmental variables monitored at fixed stations,
-   raster maps
-   time series of satellite images with multiple spectral bands,
-   spatial simulations, and
-   climate or weather model output.

This R package provides classes and methods for reading,
manipulating, plotting and writing such data cubes, to the extent
that there are proper formats for doing so.

## Raster and vector data cubes

The canonical data cube most of us have in mind is that where two
dimensions represent spatial raster dimensions, and the third time
(or band), as e.g. shown here:

```{r,out.width='50%',echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/r-spatial/stars/master/images/cube1.png")
```

By data cubes however we also consider higher-dimensional cubes
(hypercubes) such as a five-dimensional cube where in addition to
time, spectral band and sensor form dimensions:

```{r,out.width='50%',echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/r-spatial/stars/master/images/cube2.png")
```

or lower-dimensional cubes such as a raster image:
```{r}
suppressPackageStartupMessages(library(tidyverse))
library(stars)
tif = system.file("tif/L7_ETMs.tif", package = "stars")
read_stars(tif) %>%
  slice(index = 1, along = "band") %>%
  plot()
```

Raster data do not need to be regular and aligned with North/East,
and package `stars` supports besides _regular_ also _rotated_,
_sheared_, _rectilinear_ and _curvilinear_ rasters:

```{r echo=FALSE}
x = 1:5
y = 1:4
d = st_dimensions(x = x, y = y, .raster = c("x", "y"))
m = matrix(runif(20),5,4)
r1 = st_as_stars(r = m, dimensions = d)

r = attr(d, "raster")
r$affine = c(0.2, -0.2)
attr(d, "raster") = r
r2 = st_as_stars(r = m, dimensions = d)

r = attr(d, "raster")
r$affine = c(0.1, -0.3)
attr(d, "raster") = r
r3 = st_as_stars(r = m, dimensions = d)

x = c(1, 2, 3.5, 5, 6)
y = c(1, 1.5, 3, 3.5)
d = st_dimensions(x = x, y = y, .raster = c("x", "y"))
r4 = st_as_stars(r = m, dimensions = d)

grd = st_make_grid(cellsize = c(10,10), offset = c(-130,10), n= c(8,5), crs=st_crs(4326))
r5 = st_transform(grd, "+proj=laea +lon_0=-70 +lat_0=35")

par(mfrow = c(2,3))
r1 = st_make_grid(cellsize = c(1,1), n = c(5,4), offset = c(0,0))
plot(r1, main = "regular")
plot(st_geometry(st_as_sf(r2)), main = "rotated")
plot(st_geometry(st_as_sf(r3)), main = "sheared")
plot(st_geometry(st_as_sf(r4, as_points = FALSE)), main = "rectilinear")
plot(st_geometry((r5)), main = "curvilinear")
```

Vector data cubes arise when we do not have two regularly discretized spatial dimensions, but a single dimension indicating spatial feature geometries, such as polygons (e.g. denoting administrative regions):

```{r,out.width='50%',echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/r-spatial/stars/master/images/cube3.png")
```

or points (e.g. denoting sensor locations):

```{r,out.width='50%',echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/r-spatial/stars/master/images/cube4.png")
```

## NetCDF, GDAL

`stars` provides two functions to read data: `read_ncdf` and
`read_stars`, where the latter reads through GDAL. (In the future,
both will be integrated in `read_stars`.) For reading NetCDF files,
package `RNetCDF` is used, for reading through GDAL, package `sf`
provides the binary linking to GDAL.

For vector and raster operations, `stars` uses as much as possible
the routines available in GDAL and PROJ (e.g. `st_transform`,
`rasterize`, `polygonize`, `warp`). Read more about this in
the vignette on [vector-raster conversions, reprojection,
warping](https://r-spatial.github.io/stars/articles/stars5.html).

## Out-of-memory (on-disk) rasters

Package `stars` provides `stars_proxy` objects (currently only when
read through GDAL), which contain only the dimensions metadata and
pointers to the files on disk. These objects work lazily: reading
and processing data is postponed to the moment that pixels are
really needed (at plot time, or when writing to disk), and is done
at the lowest spatial resolution possible that still fulfills the
resolution of the graphics device. More
details are found in the [stars proxy
vignette](https://r-spatial.github.io/stars/articles/stars2.html).

The following methods are currently available for `stars_proxy` objects:
```{r}
methods(class = "stars_proxy")
```

## Raster and vector time series analysis example

In the following, a curvilinear grid with hourly precipitation values of
a hurricane is imported and the first 12 time steps are plotted:

```{r}
library(stars)
suppressPackageStartupMessages(library(dplyr)) # for slice generic
prec_file = system.file("nc/test_stageiv_xyt.nc", package = "stars")
(prec = read_ncdf(prec_file, curvilinear = c("lon", "lat"), ignore_bounds = TRUE))
sf::read_sf(system.file("gpkg/nc.gpkg", package = "sf"), "nc.gpkg") %>%
  st_transform(st_crs(prec)) -> nc # transform from NAD27 to WGS84
nc_outline = st_union(st_geometry(nc))
plot_hook = function() plot(nc_outline, border = 'red', add = TRUE)
prec %>%
  slice(index = 1:12, along = "time") %>%
  plot(downsample = c(5, 5, 1), hook = plot_hook)
```

and next, intersected with with the counties of North Carolina, where
the maximum precipitation intensity was obtained per county, and plotted:

```{r}
a = aggregate(prec, nc, max)
plot(a, max.plot = 23)
```

We can integrate over time, e.g. to find out when the maximum
precipitation occurred (here reported as the index of the time step):

```{r, fig.height=2.5}
index_max = function(x) ifelse(all(is.na(x)), NA, which.max(x))
st_apply(a, "geometry", index_max) %>%
  plot(main = "time step of maximum precipitation")
```

## Other packages for data cubes

### [`gdalcubes`](https://github.com/appelmar/gdalcubes_R/)

Package `gdalcubes` can be used to create data cubes (or functions
from them) from image collections, sets of multi-band images with
different

* spatial resolution
* spatial extent
* coordinate reference systems (e.g., spread over multiple UTM zones)
* observation times

and does this by resampling and/or aggregating over space and/or
time; it heavily reuses GDAL VRT's and gdalwarp for spatial
resampling and/or warping.

### [`ncdfgeom`](https://github.com/USGS-R/ncdfgeom)

`ncdfgeom` reads and writes vector data cubes from and to netcdf
files in a standards-compliant way.

### [`raster`](https://github.com/rspatial/raster/)

Package `raster` is a powerful package for handling raster maps
and stacks of raster maps both in memory and on disk, but does
not address

* non-raster time series, 
* rasters time series with multiple attributes, 
* rasters with mixed type attributes (e.g., numeric, logical and factor)
* rectilinear or curvilinear rasters

A list of `stars` commands matching
existing `raster` commands is found in this
[wiki](https://github.com/r-spatial/stars/wiki/How-%60raster%60-functions-map-to-%60stars%60-functions).
A list of translations in the opposite direction (from `stars` to
`raster`) still needs to be made.

## Other `stars` resources:

* blog posts: [first](http://r-spatial.org/r/2017/11/23/stars1.html),
[second](https://www.r-spatial.org/r/2018/03/22/stars2.html),
[third](https://www.r-spatial.org/r/2018/03/23/stars3.html)
* vignettes: [first](https://r-spatial.github.io/stars/articles/stars1.html), [second](https://r-spatial.github.io/stars/articles/stars2.html), [third](https://r-spatial.github.io/stars/articles/stars3.html), [fourth](https://r-spatial.github.io/stars/articles/stars4.html), [fifth](https://r-spatial.github.io/stars/articles/stars5.html)
* the original [R Consortium proposal](https://github.com/edzer/stars/blob/master/PROPOSAL.md).

### Acknowledgment

This project has been realized with financial
[support](https://www.r-consortium.org/blog/2017/04/03/q1-2017-isc-grants)
from the

<a href="https://www.r-consortium.org/projects/awarded-projects">
<img src="http://pebesma.staff.ifgi.de/RConsortium_Horizontal_Pantone.png" width="400">
</a>
