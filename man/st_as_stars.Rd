% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stars.R, R/sf.R, R/raster.R, R/proxy.R,
%   R/cubes.R
\name{st_as_stars}
\alias{st_as_stars}
\alias{st_as_stars.list}
\alias{st_as_stars.default}
\alias{st_as_stars.stars}
\alias{st_as_stars.bbox}
\alias{st_as_stars.sf}
\alias{st_as_stars.Raster}
\alias{st_as_stars.stars_proxy}
\alias{st_as_stars.cube}
\title{convert objects into a stars object}
\usage{
st_as_stars(.x, ...)

\method{st_as_stars}{list}(.x, ..., dimensions = NULL)

\method{st_as_stars}{default}(.x = NULL, ..., raster = NULL)

\method{st_as_stars}{stars}(.x, ..., curvilinear = NULL,
  crs = st_crs(4326))

\method{st_as_stars}{bbox}(.x, ..., nx = 360, ny = 180,
  deltax = diff(xlim)/nx, deltay = -diff(ylim)/ny,
  xlim = .x[c("xmin", "xmax")], ylim = .x[c("ymin", "ymax")],
  values = 0)

\method{st_as_stars}{sf}(.x, ..., name = attr(.x, "sf_column"))

\method{st_as_stars}{Raster}(.x, ...)

\method{st_as_stars}{stars_proxy}(.x, ..., downsample = 0,
  url = attr(.x, "url"), env = parent.frame())

\method{st_as_stars}{cube}(.x, ..., proxy = TRUE)
}
\arguments{
\item{.x}{object to convert}

\item{...}{ignored}

\item{dimensions}{object of class dimensions}

\item{raster}{character; the names of the dimensions that denote raster dimensions}

\item{curvilinear}{only for creating curvilinear grids: named length 2 list holding longitude and latitude matrices; the names of this list should correspond to raster dimensions to be replaced}

\item{crs}{object of class \code{crs} with the coordinate reference system of the values in \code{curvilinear}; see details}

\item{nx}{integer; number of cells in x direction}

\item{ny}{integer; number of cells in y direction}

\item{deltax}{numeric; cell size in x direction}

\item{deltay}{numeric; cell size in y direction (negative)}

\item{xlim}{length 2 numeric vector with extent (min, max) in x direction}

\item{ylim}{length 2 numeric vector with extent (min, max) in y direction}

\item{values}{value(s) to populate the raster values with}

\item{name}{character; name for the geometry dimensions}

\item{downsample}{integer: if larger than 0, downsample with this rate (number of pixels to skip in every row/column); if length 2, specifies downsampling rate in x and y.}

\item{url}{character; URL of the stars endpoint where the data reside}

\item{env}{environment at the data endpoint to resolve objects in}

\item{proxy}{logical; if TRUE, create a stars proxy object and delay call to gdalcubes::write_ncdf() (not yet implemented)}
}
\description{
convert objects into a stars object

Convert an existing cube object to a stars object
}
\details{
if \code{curvilinear} is a \code{stars} object with longitude and latitude values, its coordinate reference system is typically not that of the latitude and longitude values.
}
\examples{

if(require(gdalcubes)) {
   L8_files <- list.files(system.file("L8NY18", package = "gdalcubes"), ".TIF", recursive = TRUE, full.names = TRUE)
   v = gdalcubes::cube_view(extent=list(left=388941.2, right=766552.4, 
                            bottom=4345299, top=4744931, t0="2018-01", t1="2018-12"),
                            srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
   L8.col = gdalcubes::create_image_collection(L8_files, "L8_L1TP") 
   st_as_stars(gdalcubes::raster_cube(L8.col, v), proxy=FALSE)
}
}
